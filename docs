<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analizador de Calidad de Datos</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #166088;
            --accent-color: #4fc3a1;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --success-color: #4caf50;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --gray-color: #6c757d;
            --border-radius: 10px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--dark-color);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .logo-icon {
            font-size: 2.5rem;
            color: var(--primary-color);
        }

        .logo-text {
            font-family: 'Poppins', sans-serif;
            font-size: 2rem;
            font-weight: 600;
            color: var(--dark-color);
        }

        .tagline {
            font-size: 1.1rem;
            color: var(--gray-color);
            font-weight: 300;
        }

        /* Main Content */
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }

        /* Cards */
        .card {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            margin-bottom: 25px;
            transition: var(--transition);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .card h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: var(--dark-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Left Panel */
        .upload-section {
            margin-bottom: 25px;
        }

        .upload-label {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 12px 25px;
            background: var(--primary-color);
            color: white;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
            margin-bottom: 15px;
        }

        .upload-label:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
        }

        #file-upload {
            display: none;
        }

        .file-info {
            background: var(--light-color);
            padding: 15px;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
        }

        .buttons-container {
            display: grid;
            gap: 12px;
            margin-bottom: 25px;
        }

        .btn {
            padding: 14px 20px;
            border: none;
            border-radius: var(--border-radius);
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
        }

        .btn-secondary {
            background: var(--light-color);
            color: var(--dark-color);
            border: 2px solid #dee2e6;
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-download {
            background: var(--accent-color);
            color: white;
            margin-top: 15px;
            width: 100%;
        }

        .btn-small {
            padding: 8px 15px;
            font-size: 0.9rem;
        }

        .stats-container {
            margin-top: 25px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: var(--light-color);
            border-radius: var(--border-radius);
            transition: var(--transition);
        }

        .stat-item:hover {
            background: #e9ecef;
        }

        .stat-label {
            display: block;
            font-size: 0.85rem;
            color: var(--gray-color);
            margin-bottom: 5px;
        }

        .stat-value {
            display: block;
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--primary-color);
            font-family: 'Poppins', sans-serif;
        }

        .instructions-list {
            padding-left: 20px;
            margin-top: 15px;
        }

        .instructions-list li {
            margin-bottom: 12px;
            padding-left: 5px;
        }

        /* Right Panel */
        .console-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .console-output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: var(--border-radius);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            min-height: 200px;
        }

        .console-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 5px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message-success {
            background: rgba(76, 175, 80, 0.1);
            border-left: 4px solid var(--success-color);
            color: #4caf50;
        }

        .message-warning {
            background: rgba(255, 152, 0, 0.1);
            border-left: 4px solid var(--warning-color);
            color: #ff9800;
        }

        .message-error {
            background: rgba(244, 67, 54, 0.1);
            border-left: 4px solid var(--danger-color);
            color: #f44336;
        }

        .message-info {
            background: rgba(33, 150, 243, 0.1);
            border-left: 4px solid var(--primary-color);
            color: var(--primary-color);
        }

        .welcome-message {
            text-align: center;
            padding: 40px 20px;
            color: var(--gray-color);
        }

        .welcome-message i {
            font-size: 3rem;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        /* Results */
        .results-header {
            margin-bottom: 20px;
        }

        .result-tabs {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 10px 20px;
            background: var(--light-color);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
        }

        .tab-btn:hover {
            background: #e9ecef;
        }

        .tab-btn.active {
            background: var(--primary-color);
            color: white;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .tab-content.active {
            display: block;
        }

        .no-data {
            text-align: center;
            padding: 40px 20px;
            color: var(--gray-color);
        }

        .no-data i {
            font-size: 2.5rem;
            margin-bottom: 15px;
            color: #adb5bd;
        }

        /* Tables */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .data-table th {
            background: var(--primary-color);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 500;
        }

        .data-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #dee2e6;
        }

        .data-table tr:hover {
            background: var(--light-color);
        }

        .data-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        /* Download Section */
        .download-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .download-item {
            text-align: center;
            padding: 25px;
            background: var(--light-color);
            border-radius: var(--border-radius);
            transition: var(--transition);
            border: 2px solid transparent;
        }

        .download-item:hover {
            border-color: var(--accent-color);
            transform: translateY(-5px);
        }

        .download-item i {
            font-size: 2.5rem;
            margin-bottom: 15px;
        }

        .download-item i.fa-file-csv {
            color: var(--success-color);
        }

        .download-item i.fa-file-excel {
            color: var(--success-color);
        }

        .download-item i.fa-file-alt {
            color: var(--warning-color);
        }

        .download-item h3 {
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: var(--dark-color);
        }

        .download-item p {
            font-size: 0.9rem;
            color: var(--gray-color);
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 25px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            margin-top: 30px;
        }

        .footer p {
            margin-bottom: 15px;
            color: var(--gray-color);
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 25px;
        }

        .footer-links a {
            color: var(--primary-color);
            text-decoration: none;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .footer-links a:hover {
            color: var(--secondary-color);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            position: relative;
            background: white;
            max-width: 600px;
            margin: 50px auto;
            border-radius: var(--border-radius);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid #dee2e6;
        }

        .modal-body {
            padding: 25px;
            max-height: 400px;
            overflow-y: auto;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--gray-color);
            transition: var(--transition);
        }

        .close-modal:hover {
            color: var(--danger-color);
        }

        /* Loading Overlay */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        .spinner {
            text-align: center;
        }

        .spinner i {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .spinner p {
            font-size: 1.1rem;
            color: var(--dark-color);
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .logo-text {
                font-size: 1.5rem;
            }
            
            .buttons-container {
                grid-template-columns: 1fr;
            }
            
            .download-grid {
                grid-template-columns: 1fr;
            }
            
            .result-tabs {
                flex-direction: column;
            }
            
            .modal-content {
                margin: 20px;
            }
        }

        @media (max-width: 480px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .footer-links {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo-container">
                <i class="fas fa-chart-bar logo-icon"></i>
                <h1 class="logo-text">Analizador de Calidad de Datos</h1>
            </div>
            <p class="tagline">Combina, analiza y optimiza tus datasets de forma inteligente</p>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Left Panel: Controls -->
            <div class="left-panel">
                <div class="card control-card">
                    <h2><i class="fas fa-cogs"></i> Controles Principales</h2>
                    
                    <div class="upload-section">
                        <label for="file-upload" class="upload-label">
                            <i class="fas fa-cloud-upload-alt"></i> Cargar Archivo(s)
                        </label>
                        <input type="file" id="file-upload" multiple accept=".csv,.xlsx,.xls">
                        <div class="file-info">
                            <p id="selected-files">No hay archivos seleccionados</p>
                        </div>
                    </div>

                    <div class="buttons-container">
                        <button id="analyze-btn" class="btn btn-primary">
                            <i class="fas fa-search"></i> Generar Análisis
                        </button>
                        <button id="summary-btn" class="btn btn-secondary">
                            <i class="fas fa-list"></i> Ver Resumen
                        </button>
                        <button id="clear-btn" class="btn btn-warning">
                            <i class="fas fa-trash"></i> Limpiar Archivos
                        </button>
                    </div>

                    <div class="stats-container">
                        <h3><i class="fas fa-chart-pie"></i> Estadísticas</h3>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-label">Archivos</span>
                                <span id="file-count" class="stat-value">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Registros</span>
                                <span id="record-count" class="stat-value">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Columnas</span>
                                <span id="column-count" class="stat-value">0</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card instructions-card">
                    <h2><i class="fas fa-graduation-cap"></i> Instrucciones</h2>
                    <ol class="instructions-list">
                        <li>Selecciona uno o más archivos CSV/Excel</li>
                        <li>Puedes agregar más archivos si es necesario</li>
                        <li>Revisa el resumen de archivos cargados</li>
                        <li>Genera el análisis combinado</li>
                        <li>Descarga los resultados y el informe</li>
                    </ol>
                </div>
            </div>

            <!-- Right Panel: Console & Results -->
            <div class="right-panel">
                <div class="card console-card">
                    <div class="console-header">
                        <h2><i class="fas fa-terminal"></i> Consola de Progreso</h2>
                        <button id="clear-console" class="btn btn-small">
                            <i class="fas fa-eraser"></i> Limpiar
                        </button>
                    </div>
                    <div class="console-output" id="console-output">
                        <div class="welcome-message">
                            <i class="fas fa-robot"></i>
                            <p>Bienvenido al Analizador de Calidad de Datos. Sube tus archivos para comenzar.</p>
                        </div>
                    </div>
                </div>

                <div class="card results-card">
                    <div class="results-header">
                        <h2><i class="fas fa-chart-line"></i> Resultados del Análisis</h2>
                        <div class="result-tabs">
                            <button class="tab-btn active" data-tab="missing">Faltantes</button>
                            <button class="tab-btn" data-tab="duplicates">Duplicados</button>
                            <button class="tab-btn" data-tab="inconsistencies">Inconsistencias</button>
                            <button class="tab-btn" data-tab="mixed">Tipos Mezclados</button>
                            <button class="tab-btn" data-tab="outliers">Atípicos</button>
                        </div>
                    </div>
                    
                    <div class="results-content">
                        <div class="tab-content active" id="missing-tab">
                            <div class="no-data" id="missing-data">
                                <i class="fas fa-search"></i>
                                <p>No hay datos de valores faltantes para mostrar</p>
                            </div>
                            <div id="missing-table"></div>
                        </div>
                        
                        <div class="tab-content" id="duplicates-tab">
                            <div class="no-data" id="duplicates-data">
                                <i class="fas fa-search"></i>
                                <p>No hay datos de duplicados para mostrar</p>
                            </div>
                            <div id="duplicates-table"></div>
                        </div>
                        
                        <div class="tab-content" id="inconsistencies-tab">
                            <div class="no-data" id="inconsistencies-data">
                                <i class="fas fa-search"></i>
                                <p>No hay inconsistencias críticas para mostrar</p>
                            </div>
                            <div id="inconsistencies-table"></div>
                        </div>
                        
                        <div class="tab-content" id="mixed-tab">
                            <div class="no-data" id="mixed-data">
                                <i class="fas fa-search"></i>
                                <p>No hay tipos de datos mezclados para mostrar</p>
                            </div>
                            <div id="mixed-table"></div>
                        </div>
                        
                        <div class="tab-content" id="outliers-tab">
                            <div class="no-data" id="outliers-data">
                                <i class="fas fa-search"></i>
                                <p>No hay valores atípicos para mostrar</p>
                            </div>
                            <div id="outliers-table"></div>
                        </div>
                    </div>
                </div>

                <!-- Download Section -->
                <div class="card download-card" id="download-section" style="display: none;">
                    <h2><i class="fas fa-download"></i> Descargas Disponibles</h2>
                    <div class="download-grid">
                        <div class="download-item" id="csv-download">
                            <i class="fas fa-file-csv"></i>
                            <h3>Archivo Fusionado (CSV)</h3>
                            <p>Formato universal compatible</p>
                            <button class="btn btn-download" data-type="csv">
                                <i class="fas fa-download"></i> Descargar CSV
                            </button>
                        </div>
                        <div class="download-item" id="excel-download">
                            <i class="fas fa-file-excel"></i>
                            <h3>Archivo Fusionado (Excel)</h3>
                            <p>Formato nativo de Excel</p>
                            <button class="btn btn-download" data-type="excel">
                                <i class="fas fa-download"></i> Descargar Excel
                            </button>
                        </div>
                        <div class="download-item" id="report-download">
                            <i class="fas fa-file-alt"></i>
                            <h3>Informe de Análisis</h3>
                            <p>Reporte detallado en TXT</p>
                            <button class="btn btn-download" data-type="report">
                                <i class="fas fa-download"></i> Descargar Informe
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <p>© 2024 Analizador de Calidad de Datos | Desarrollado con <i class="fas fa-heart"></i> para análisis de datos</p>
            <div class="footer-links">
                <a href="#"><i class="fas fa-question-circle"></i> Ayuda</a>
                <a href="#"><i class="fas fa-info-circle"></i> Acerca de</a>
                <a href="#"><i class="fas fa-envelope"></i> Contacto</a>
            </div>
        </footer>
    </div>

    <!-- Modals -->
    <div id="summary-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fas fa-clipboard-list"></i> Resumen de Archivos Cargados</h2>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div id="summary-content"></div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="spinner">
            <i class="fas fa-spinner fa-spin"></i>
            <p>Procesando archivos...</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <script>
        // Clase principal para el análisis de calidad de datos
        class DataQualityAnalyzer {
            constructor() {
                this.currentData = null;
                this.currentFilename = "";
                this.reportText = "";
                this.consoleMessages = [];
                this.combinedData = null;
                this.uploadedFilesInfo = [];
                this.tempDataframes = [];
                this.uploadedFilenames = [];
                this.mergedFilenameCSV = "";
                this.mergedFilenameExcel = "";
                this.reportFilename = "";
                this.analysisResults = {
                    missing: null,
                    duplicates: null,
                    inconsistencies: null,
                    mixedTypes: null,
                    outliers: null
                };
            }

            addConsoleMessage(message, msgType = "info") {
                const timestamp = new Date().toLocaleTimeString();
                this.consoleMessages.push({
                    timestamp,
                    message,
                    type: msgType
                });
                return { timestamp, message, type: msgType };
            }

            async addFileToAnalysis(fileContent, fileName) {
                try {
                    // Verificar si el archivo ya fue cargado
                    if (this.uploadedFilenames.includes(fileName)) {
                        return {
                            success: false,
                            message: `ADVERTENCIA: El archivo '${fileName}' ya fue cargado anteriormente. Se omitirá.`
                        };
                    }

                    let df;
                    if (fileName.toLowerCase().endsWith('.csv')) {
                        df = await this.readCSVFile(fileContent);
                    } else if (fileName.toLowerCase().endsWith('.xlsx') || fileName.toLowerCase().endsWith('.xls')) {
                        df = await this.readExcelFile(fileContent);
                    } else {
                        return {
                            success: false,
                            message: `ERROR: Formato no compatible en '${fileName}'. Formato debe ser .csv o .xlsx`
                        };
                    }

                    // Verificar que las columnas sean compatibles
                    if (this.tempDataframes.length > 0) {
                        const existingColumns = this.tempDataframes[0]._columns || [];
                        const newColumns = df._columns || [];
                        
                        // Crear sets para comparar
                        const existingSet = new Set(existingColumns);
                        const newSet = new Set(newColumns);
                        
                        // Verificar si los sets son iguales
                        let columnsMatch = existingColumns.length === newColumns.length;
                        if (columnsMatch) {
                            for (const col of existingColumns) {
                                if (!newSet.has(col)) {
                                    columnsMatch = false;
                                    break;
                                }
                            }
                        }

                        if (!columnsMatch) {
                            const missingInNew = existingColumns.filter(col => !newSet.has(col));
                            const extraInNew = newColumns.filter(col => !existingSet.has(col));

                            let warningMsg = `ADVERTENCIA: Las columnas no coinciden exactamente en '${fileName}'.\n`;
                            
                            if (missingInNew.length > 0) {
                                warningMsg += `  Columnas faltantes: ${missingInNew.join(', ')}\n`;
                            }
                            if (extraInNew.length > 0) {
                                warningMsg += `  Columnas adicionales: ${extraInNew.join(', ')}\n`;
                            }

                            // Intentar alinear columnas
                            const commonColumns = existingColumns.filter(col => newSet.has(col));
                            if (commonColumns.length > 0) {
                                warningMsg += `  Se usarán ${commonColumns.length} columnas comunes\n`;
                                
                                // Filtrar solo las columnas comunes
                                df = df.map(row => {
                                    const newRow = {};
                                    commonColumns.forEach(col => {
                                        newRow[col] = row[col];
                                    });
                                    return newRow;
                                });
                                df._columns = commonColumns;
                            } else {
                                return {
                                    success: false,
                                    message: `ERROR: No hay columnas comunes entre los archivos. No se puede combinar.`
                                };
                            }

                            this.addConsoleMessage(warningMsg, "warning");
                        }
                    }

                    // Guardar información del archivo
                    this.uploadedFilesInfo.push({
                        nombre: fileName,
                        filas: df.length,
                        columnas: df._columns ? df._columns.length : 0,
                        fechaCarga: new Date().toLocaleTimeString()
                    });

                    this.tempDataframes.push(df);
                    this.uploadedFilenames.push(fileName);

                    const successMsg = `✓ Archivo '${fileName}' cargado exitosamente: ${df.length} filas, ${df._columns ? df._columns.length : 0} columnas`;
                    return {
                        success: true,
                        message: successMsg,
                        dataframe: df
                    };

                } catch (error) {
                    return {
                        success: false,
                        message: `ERROR al procesar '${fileName}': ${error.message}`
                    };
                }
            }

            async readCSVFile(content) {
                return new Promise((resolve, reject) => {
                    Papa.parse(content, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            const df = results.data;
                            // Convertir a DataFrame con metadatos
                            df._columns = results.meta.fields || [];
                            df._length = df.length;
                            resolve(df);
                        },
                        error: (error) => reject(error)
                    });
                });
            }

            async readExcelFile(content) {
                try {
                    const data = new Uint8Array(content);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                    
                    if (jsonData.length === 0) {
                        return [];
                    }
                    
                    const headers = jsonData[0];
                    const rows = jsonData.slice(1);
                    
                    const df = rows.map(row => {
                        const obj = {};
                        headers.forEach((header, index) => {
                            obj[header] = row[index] !== undefined ? row[index] : null;
                        });
                        return obj;
                    });

                    df._columns = headers || [];
                    df._length = df.length;
                    return df;
                } catch (error) {
                    console.error('Error reading Excel file:', error);
                    throw error;
                }
            }

            combineUploadedFiles() {
                if (this.tempDataframes.length === 0) {
                    this.addConsoleMessage("No hay archivos cargados para combinar.", "warning");
                    return [];
                }

                this.addConsoleMessage("Combinando archivos cargados...", "info");

                // Combinar todos los DataFrames
                let combinedDf = [];
                this.tempDataframes.forEach(df => {
                    combinedDf = [...combinedDf, ...df];
                });

                // Información resumen
                const totalFiles = this.tempDataframes.length;
                const totalRows = this.tempDataframes.reduce((sum, df) => sum + df.length, 0);
                const totalColumns = this.tempDataframes[0] ? (this.tempDataframes[0]._columns || []).length : 0;

                this.addConsoleMessage(`✓ ${totalFiles} archivo(s) combinado(s) exitosamente`, "success");
                this.addConsoleMessage(`✓ Total de registros: ${totalRows}`, "success");
                this.addConsoleMessage(`✓ Total de columnas: ${totalColumns}`, "success");

                // Copiar metadatos
                combinedDf._columns = this.tempDataframes[0] ? [...(this.tempDataframes[0]._columns || [])] : [];
                combinedDf._length = combinedDf.length;

                return combinedDf;
            }

            clearUploadedFiles() {
                this.tempDataframes = [];
                this.uploadedFilesInfo = [];
                this.uploadedFilenames = [];
                this.addConsoleMessage("✓ Todos los archivos han sido eliminados de la lista de carga.", "info");
            }

            getUploadSummary() {
                if (this.uploadedFilesInfo.length === 0) {
                    return "No hay archivos cargados.";
                }

                let summaryLines = [];
                summaryLines.push(`Archivos cargados (${this.uploadedFilesInfo.length}):`);

                let totalRows = 0;
                this.uploadedFilesInfo.forEach((fileInfo, index) => {
                    summaryLines.push(`  ${index + 1}. ${fileInfo.nombre} - ${fileInfo.filas} filas, ${fileInfo.columnas} columnas`);
                    totalRows += fileInfo.filas;
                });

                summaryLines.push(`\nTotal combinado: ${totalRows} registros`);
                return summaryLines.join('\n');
            }

            findNameColumns(columns) {
                const nameKeywords = [
                    'nombre', 'name', 'nombres',
                    'nombres completos', 'persona', 'cliente',
                    'usuario', 'paciente', 'empleado', 'estudiante'
                ];

                const nameColumns = [];
                columns.forEach(col => {
                    const colLower = col.toLowerCase();
                    for (const keyword of nameKeywords) {
                        if (colLower.includes(keyword)) {
                            nameColumns.push(col);
                            break;
                        }
                    }
                });

                return nameColumns;
            }

            getNameFromRecord(record, nameColumns) {
                // Buscar en columnas específicas de nombres
                for (const col of nameColumns) {
                    const value = record[col];
                    if (value !== null && value !== undefined && value !== '') {
                        const strValue = String(value).trim();
                        if (strValue !== '') {
                            return strValue;
                        }
                    }
                }

                // Si no encuentra en las columnas específicas, buscar en todas las columnas
                for (const [col, value] of Object.entries(record)) {
                    if (value !== null && value !== undefined && value !== '') {
                        const strValue = String(value).trim();
                        // Verificar si parece un nombre (solo letras y espacios)
                        const nameRegex = /^[A-Za-zÁÉÍÓÚáéíóúÑñ\s]+$/;
                        if (strValue !== '' && nameRegex.test(strValue) && strValue.includes(' ')) {
                            return strValue;
                        }
                    }
                }

                return null;
            }

            analyzeMissingValues(df, nameColumns) {
                const missingData = [];
                const columns = df._columns || (df.length > 0 ? Object.keys(df[0]) : []);
                
                if (df.length === 0) {
                    return { reportText: "**2. ANÁLISIS DE VALORES FALTANTES**\n\nNo hay datos para analizar.\n\n", missingData: null };
                }

                columns.forEach(col => {
                    let missingCount = 0;
                    const missingRows = [];
                    
                    // Contar valores faltantes por fila
                    df.forEach((row, idx) => {
                        const value = row[col];
                        // Considerar como faltante: null, undefined, string vacío, solo espacios
                        if (value === null || 
                            value === undefined || 
                            value === '' || 
                            (typeof value === 'string' && value.trim() === '') ||
                            (typeof value === 'number' && isNaN(value))) {
                            missingCount++;
                            missingRows.push(idx);
                        }
                    });

                    if (missingCount > 0) {
                        const pct = (missingCount / df.length) * 100;
                        const excelRows = missingRows.map(idx => idx + 2).sort((a, b) => a - b);
                        
                        // Obtener nombres asociados a los registros con valores faltantes
                        const names = [];
                        missingRows.forEach(idx => {
                            const name = this.getNameFromRecord(df[idx], nameColumns);
                            if (name) names.push(name);
                        });

                        const uniqueNames = [...new Set(names)];

                        missingData.push({
                            Columna: col,
                            'Valores Faltantes': missingCount,
                            '% del Total': `${pct.toFixed(1)}%`,
                            'Filas de Excel': excelRows.join(', '),
                            'Nombres Asociados': uniqueNames.length > 0 ? uniqueNames.join(', ') : 'No encontrados'
                        });
                    }
                });

                let reportText = "**2. ANÁLISIS DE VALORES FALTANTES**\n\n";
                
                if (missingData.length > 0) {
                    reportText += `  Se han identificado valores faltantes en ${missingData.length} columna(s). Se recomienda investigar y tratar estos valores para asegurar la completitud de los datos.\n\n`;
                } else {
                    reportText += "  ✓ No se encontraron valores faltantes en ninguna columna.\n\n";
                }

                this.analysisResults.missing = missingData.length > 0 ? missingData : null;
                return { reportText, missingData: missingData.length > 0 ? missingData : null };
            }

            analyzeDuplicates(df, nameColumns) {
                const duplicatesData = [];
                const inconsistenciesData = [];
                const columns = df._columns || (df.length > 0 ? Object.keys(df[0]) : []);
                
                if (df.length === 0) {
                    return { 
                        reportText: "**3. ANÁLISIS DE FILAS DUPLICADOS**\n\nNo hay datos para analizar.\n\n", 
                        duplicatesData: null, 
                        inconsistenciesData: null 
                    };
                }

                let reportText = "**3. ANÁLISIS DE FILAS DUPLICADOS**\n\n";

                if (!columns.includes('CC')) {
                    reportText += "  ADVERTENCIA: La columna 'CC' no fue encontrada. La detección de duplicados se realizará considerando todas las columnas del dataset.\n";
                    
                    // Buscar duplicados basados en todas las columnas
                    const seen = new Map();
                    const duplicateGroups = new Map(); // Para agrupar duplicados
                    
                    df.forEach((row, idx) => {
                        // Crear una clave única basada en todos los valores de la fila
                        const key = JSON.stringify(row);
                        
                        if (seen.has(key)) {
                            // Es un duplicado
                            const originalIdx = seen.get(key);
                            if (!duplicateGroups.has(originalIdx)) {
                                duplicateGroups.set(originalIdx, {
                                    rows: [originalIdx + 2],
                                    records: [df[originalIdx]]
                                });
                            }
                            duplicateGroups.get(originalIdx).rows.push(idx + 2);
                        } else {
                            seen.set(key, idx);
                        }
                    });

                    if (duplicateGroups.size > 0) {
                        // Convertir grupos a formato de tabla
                        duplicateGroups.forEach((group, originalIdx) => {
                            if (group.rows.length > 1) {
                                const originalRecord = df[originalIdx];
                                const names = [];
                                
                                // Obtener nombres de todas las filas duplicadas
                                group.rows.forEach(rowNum => {
                                    const rowIdx = rowNum - 2;
                                    const name = this.getNameFromRecord(df[rowIdx], nameColumns);
                                    if (name) names.push(name);
                                });

                                const uniqueNames = [...new Set(names)];

                                duplicatesData.push({
                                    'Registro Duplicado': this.truncateRecord(originalRecord),
                                    'Ocurrencias': group.rows.length,
                                    'Filas de Excel': group.rows.join(', '),
                                    'Nombres Asociados': uniqueNames.length > 0 ? uniqueNames.join(', ') : 'No encontrados'
                                });
                            }
                        });

                        const totalDuplicates = duplicatesData.reduce((sum, item) => sum + (item.Ocurrencias - 1), 0);
                        reportText += `  Total de filas duplicadas (excluyendo la primera ocurrencia): ${totalDuplicates}\n`;
                    } else {
                        reportText += "  ✓ No se encontraron filas duplicadas basadas en todas las columnas.\n\n";
                    }
                } else {
                    // Buscar duplicados basados en CC
                    const ccMap = new Map();
                    
                    // Primera pasada: agrupar por CC
                    df.forEach((row, idx) => {
                        const cc = row['CC'];
                        if (cc !== null && cc !== undefined && cc !== '') {
                            const ccKey = String(cc);
                            if (!ccMap.has(ccKey)) {
                                ccMap.set(ccKey, {
                                    rows: [idx + 2],
                                    records: [row],
                                    names: []
                                });
                            } else {
                                ccMap.get(ccKey).rows.push(idx + 2);
                                ccMap.get(ccKey).records.push(row);
                            }
                            
                            const name = this.getNameFromRecord(row, nameColumns);
                            if (name) ccMap.get(ccKey).names.push(name);
                        }
                    });

                    // Segunda pasada: procesar CC duplicados
                    let duplicatesCount = 0;
                    ccMap.forEach((data, cc) => {
                        if (data.rows.length > 1) {
                            duplicatesCount++;
                            
                            const uniqueNames = [...new Set(data.names)];

                            duplicatesData.push({
                                'Valor de CC': cc,
                                'Ocurrencias': data.rows.length,
                                'Filas de Excel': data.rows.join(', '),
                                'Nombres Asociados': uniqueNames.length > 0 ? uniqueNames.join(', ') : 'No encontrados'
                            });

                            // Verificar inconsistencias - comparar todos los registros con el mismo CC
                            const records = data.records;
                            let hasInconsistency = false;
                            
                            // Comparar cada registro con el primero
                            for (let i = 1; i < records.length; i++) {
                                const firstRecord = records[0];
                                const currentRecord = records[i];
                                
                                // Comparar todas las columnas excepto 'CC'
                                for (const key of columns) {
                                    if (key !== 'CC') {
                                        const val1 = firstRecord[key];
                                        const val2 = currentRecord[key];
                                        
                                        // Convertir a strings para comparación
                                        const str1 = val1 !== null && val1 !== undefined ? String(val1).trim() : '';
                                        const str2 = val2 !== null && val2 !== undefined ? String(val2).trim() : '';
                                        
                                        if (str1 !== str2) {
                                            hasInconsistency = true;
                                            break;
                                        }
                                    }
                                }
                                if (hasInconsistency) break;
                            }

                            if (hasInconsistency) {
                                inconsistenciesData.push({
                                    'CC Inconsistente': cc,
                                    'Ocurrencias': data.rows.length,
                                    'Filas de Excel': data.rows.join(', '),
                                    'Nombres Asociados': uniqueNames.length > 0 ? uniqueNames.join(', ') : 'No encontrados'
                                });
                            }
                        }
                    });

                    reportText += `  Total de filas con 'CC' duplicado (excluyendo la primera ocurrencia): ${duplicatesCount}\n`;

                    if (inconsistenciesData.length > 0) {
                        reportText += `  ***ADVERTENCIA DE INCONSISTENCIA CRÍTICA***\n`;
                        reportText += `  Se encontraron ${inconsistenciesData.length} valores de 'CC' que se repiten, pero los demás datos asociados a esos 'CC' son **DIFERENTES**. Esto indica problemas graves de integridad de datos que requieren una revisión URGENTE.\n`;
                        reportText += `  **Detalles de las inconsistencias:**\n`;
                    }

                    if (duplicatesCount === 0) {
                        reportText += "  ✓ No se encontraron valores 'CC' duplicados.\n\n";
                    }
                }

                // Ordenar por número de ocurrencias (descendente)
                duplicatesData.sort((a, b) => b.Ocurrencias - a.Ocurrencias);
                
                this.analysisResults.duplicates = duplicatesData.length > 0 ? duplicatesData : null;
                this.analysisResults.inconsistencies = inconsistenciesData.length > 0 ? inconsistenciesData : null;
                
                return { 
                    reportText, 
                    duplicatesData: duplicatesData.length > 0 ? duplicatesData : null,
                    inconsistenciesData: inconsistenciesData.length > 0 ? inconsistenciesData : null
                };
            }

            truncateRecord(record) {
                const str = JSON.stringify(record);
                return str.length > 100 ? str.substring(0, 100) + '...' : str;
            }

            analyzeDataTypes(df) {
                const typeCounts = {};
                const columns = df._columns || (df.length > 0 ? Object.keys(df[0]) : []);
                
                if (df.length === 0) {
                    return "**4. RESUMEN DE TIPOS DE DATOS**\n\nNo hay datos para analizar.\n\n";
                }

                columns.forEach(col => {
                    const sampleValue = df[0][col];
                    let type = typeof sampleValue;
                    
                    if (type === 'number') {
                        type = Number.isInteger(sampleValue) ? 'integer' : 'float';
                    } else if (sampleValue instanceof Date) {
                        type = 'date';
                    } else if (typeof sampleValue === 'string') {
                        type = 'string';
                    } else if (typeof sampleValue === 'boolean') {
                        type = 'boolean';
                    } else if (sampleValue === null || sampleValue === undefined) {
                        type = 'null';
                    }
                    
                    typeCounts[type] = (typeCounts[type] || 0) + 1;
                });

                let reportText = "**4. RESUMEN DE TIPOS DE DATOS**\n\n";
                Object.entries(typeCounts).forEach(([type, count]) => {
                    reportText += `  - Tipo '${type}': ${count} columna(s)\n`;
                });
                reportText += "\n";

                return reportText;
            }

            analyzeMixedTypes(df) {
                const mixedTypeData = [];
                const columns = df._columns || (df.length > 0 ? Object.keys(df[0]) : []);
                
                columns.forEach(col => {
                    const values = df.map(row => row[col]).filter(val => val != null);
                    if (values.length > 1) {
                        const types = new Set();
                        values.forEach(val => {
                            if (typeof val === 'number') {
                                types.add('number');
                            } else if (typeof val === 'string') {
                                types.add('string');
                            } else if (typeof val === 'boolean') {
                                types.add('boolean');
                            } else if (val instanceof Date) {
                                types.add('date');
                            } else if (Array.isArray(val)) {
                                types.add('array');
                            } else if (typeof val === 'object') {
                                types.add('object');
                            }
                        });

                        if (types.size > 1) {
                            mixedTypeData.push({
                                Columna: col,
                                'Tipos Detectados': Array.from(types).join(', ')
                            });
                        }
                    }
                });

                let reportText = "**5. ANÁLISIS DE TIPOS DE DATOS MEZCLADOS (Columnas 'Object')**\n\n";
                
                if (mixedTypeData.length > 0) {
                    reportText += "\n  Se han identificado columnas con tipos de datos inconsistentes. Se recomienda estandarizar los tipos de datos para evitar errores en análisis futuros.\n\n";
                } else {
                    reportText += "  ✓ No se encontraron columnas de tipo 'object' con tipos de datos mezclados significativos.\n\n";
                }

                this.analysisResults.mixedTypes = mixedTypeData.length > 0 ? mixedTypeData : null;
                return { reportText, mixedTypeData: mixedTypeData.length > 0 ? mixedTypeData : null };
            }

            analyzeOutliers(df) {
                const outliersData = [];
                const columns = df._columns || (df.length > 0 ? Object.keys(df[0]) : []);
                
                columns.forEach(col => {
                    // Filtrar valores numéricos válidos
                    const numericValues = df
                        .map(row => {
                            const val = row[col];
                            if (val === null || val === undefined || val === '') return NaN;
                            const num = parseFloat(val);
                            return isNaN(num) ? NaN : num;
                        })
                        .filter(val => !isNaN(val));
                    
                    if (numericValues.length >= 4) {
                        // Ordenar valores
                        const sortedValues = [...numericValues].sort((a, b) => a - b);
                        
                        // Calcular cuartiles
                        const q1 = this.calculatePercentile(sortedValues, 25);
                        const q3 = this.calculatePercentile(sortedValues, 75);
                        const iqr = q3 - q1;
                        
                        if (iqr > 0) {
                            const lowerBound = q1 - (1.5 * iqr);
                            const upperBound = q3 + (1.5 * iqr);
                            
                            const outliers = numericValues.filter(val => val < lowerBound || val > upperBound);
                            
                            if (outliers.length > 0) {
                                outliersData.push({
                                    Columna: col,
                                    'Posibles Atípicos': outliers.length,
                                    'Rango IQR': `${lowerBound.toFixed(2)} - ${upperBound.toFixed(2)}`
                                });
                            }
                        }
                    }
                });

                let reportText = "**6. ANÁLISIS DE VALORES ATÍPICOS NUMÉRICOS (Método IQR)**\n\n";
                
                if (outliersData.length > 0) {
                    reportText += "\n  Se han detectado posibles valores atípicos en columnas numéricas. Se sugiere una revisión para determinar si son errores de entrada o variaciones legítimas de los datos.\n\n";
                } else {
                    reportText += "  ✓ No se encontraron valores atípicos significativos en columnas numéricas.\n\n";
                }

                this.analysisResults.outliers = outliersData.length > 0 ? outliersData : null;
                return { reportText, outliersData: outliersData.length > 0 ? outliersData : null };
            }

            calculatePercentile(sortedValues, percentile) {
                if (sortedValues.length === 0) return 0;
                
                const index = (percentile / 100) * (sortedValues.length - 1);
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                
                if (lower === upper) {
                    return sortedValues[lower];
                }
                
                const weight = index - lower;
                return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;
            }

            generateReport(df, filenames) {
                this.addConsoleMessage("Generando informe de calidad de datos combinado...", "info");

                const nameColumns = this.findNameColumns(df._columns || (df.length > 0 ? Object.keys(df[0]) : []));
                if (nameColumns.length > 0) {
                    this.addConsoleMessage(`✓ Columnas de nombres identificadas: ${nameColumns.join(', ')}`, "success");
                }

                let reportLines = [];

                // ENCABEZADO PRINCIPAL CON TABLAS
                reportLines.push("=".repeat(80));
                reportLines.push("📊 RESUMEN DEL INFORME GENERADO (ARCHIVOS COMBINADOS)");
                reportLines.push("=".repeat(80));
                reportLines.push("");

                // Realizar todos los análisis
                const missing = this.analyzeMissingValues(df, nameColumns);
                const duplicates = this.analyzeDuplicates(df, nameColumns);
                const dataTypes = this.analyzeDataTypes(df);
                const mixedTypes = this.analyzeMixedTypes(df);
                const outliers = this.analyzeOutliers(df);

                // AGREGAR TABLAS AL INFORME TXT
                if (missing.missingData) {
                    reportLines.push("🔍 *** VALORES FALTANTES ***");
                    const missingStr = this.arrayToTable(missing.missingData);
                    reportLines.push(missingStr);
                    reportLines.push("");
                }

                if (duplicates.duplicatesData) {
                    reportLines.push("🔍 *** FILAS DUPLICADAS ***");
                    const duplicatesStr = this.arrayToTable(duplicates.duplicatesData);
                    reportLines.push(duplicatesStr);
                    reportLines.push("");
                }

                if (duplicates.inconsistenciesData) {
                    reportLines.push("⚠️ *** INCONSISTENCIAS CRÍTICAS DE CC ***");
                    const inconsistenciesStr = this.arrayToTable(duplicates.inconsistenciesData);
                    reportLines.push(inconsistenciesStr);
                    reportLines.push("");
                }

                if (mixedTypes.mixedTypeData) {
                    reportLines.push("🔍 *** TIPOS DE DATOS MEZCLADOS ***");
                    const mixedTypesStr = this.arrayToTable(mixedTypes.mixedTypeData);
                    reportLines.push(mixedTypesStr);
                    reportLines.push("");
                }

                if (outliers.outliersData) {
                    reportLines.push("🔍 *** VALORES ATÍPICOS ***");
                    const outliersStr = this.arrayToTable(outliers.outliersData);
                    reportLines.push(outliersStr);
                    reportLines.push("");
                }

                // SEPARADOR PARA EL INFORME DETALLADO
                reportLines.push("=".repeat(80));
                reportLines.push("📝 INFORME COMPLETO DE CALIDAD DE DATOS");
                reportLines.push("=".repeat(80));

                // INFORME DETALLADO ORIGINAL
                reportLines.push("=".repeat(80));
                reportLines.push("INFORME DE CALIDAD DE DATOS - ARCHIVOS COMBINADOS");
                reportLines.push("=".repeat(80));
                reportLines.push("Este informe exhaustivo ha sido generado para ofrecer una visión clara y detallada de la calidad de los datos en su conjunto de datos combinado. A continuación, encontrará un análisis estructurado que abarca la integridad, coherencia y posibles problemas de anomalías, facilitando una revisión eficiente y la toma de decisiones informadas.\n");

                reportLines.push("**1. INFORMACIÓN GENERAL DEL DATASET COMBINADO**");

                if (this.uploadedFilesInfo.length > 0) {
                    reportLines.push(`  - Archivos cargados: ${this.uploadedFilesInfo.length}`);
                    this.uploadedFilesInfo.forEach(fileInfo => {
                        reportLines.push(`    • ${fileInfo.nombre}: ${fileInfo.filas} filas, ${fileInfo.columnas} columnas`);
                    });
                }

                reportLines.push(`  - Forma del conjunto combinado: ${df.length} Filas × ${(df._columns || (df.length > 0 ? Object.keys(df[0]) : [])).length} Columnas`);
                if (nameColumns.length > 0) {
                    reportLines.push(`  - Columnas de nombres identificadas: ${nameColumns.join(', ')}`);
                }
                reportLines.push("");

                // Agregar las secciones de análisis
                reportLines.push(missing.reportText);
                reportLines.push(duplicates.reportText);
                reportLines.push(dataTypes);
                reportLines.push(mixedTypes.reportText);
                reportLines.push(outliers.reportText);

                reportLines.push("=".repeat(80));
                reportLines.push("FIN DEL INFORME DE CALIDAD DE DATOS");
                reportLines.push("Esperamos que este Informe de Calidad de Datos le sea de gran utilidad para comprender mejor la situación de su dataset combinado. Se recomienda encarecidamente revisar los hallazgos detallados y tomar las acciones correctivas necesarias para garantizar la máxima integridad y fiabilidad de sus datos. ¡Gracias por utilizar nuestro servicio de análisis de calidad de datos!\n");

                this.reportText = reportLines.join('\n');

                // Crear nombre de archivo para el informe
                let outputFilename;
                if (filenames.length > 0) {
                    const baseName = filenames.slice(0, 2)
                        .map(f => f.replace(/\.[^/.]+$/, "").substring(0, 10).replace('.', '_'))
                        .join('_y_');
                    
                    if (filenames.length > 2) {
                        outputFilename = `informe_calidad_datos_${baseName}_y_${filenames.length - 2}_mas.txt`;
                    } else {
                        outputFilename = `informe_calidad_datos_${baseName}.txt`;
                    }
                } else {
                    outputFilename = "informe_calidad_datos.txt";
                }

                this.reportFilename = outputFilename;

                return {
                    reportText: this.reportText,
                    missingData: missing.missingData,
                    duplicatesData: duplicates.duplicatesData,
                    inconsistenciesData: duplicates.inconsistenciesData,
                    mixedTypeData: mixedTypes.mixedTypeData,
                    outliersData: outliers.outliersData,
                    filename: outputFilename
                };
            }

            arrayToTable(dataArray) {
                if (!dataArray || dataArray.length === 0) return "";
                
                const headers = Object.keys(dataArray[0]);
                let table = headers.join('\t') + '\n';
                
                dataArray.forEach(row => {
                    const rowValues = headers.map(header => row[header] || '');
                    table += rowValues.join('\t') + '\n';
                });
                
                return table;
            }

            processCombinedData() {
                if (this.tempDataframes.length === 0) {
                    this.addConsoleMessage("No hay archivos cargados para procesar. Por favor, cargue al menos un archivo.", "warning");
                    return null;
                }

                // Combinar archivos
                const combinedDf = this.combineUploadedFiles();

                if (combinedDf.length === 0) {
                    this.addConsoleMessage("No se pudo crear el dataset combinado.", "error");
                    return null;
                }

                this.currentData = combinedDf;
                this.combinedData = combinedDf;

                this.addConsoleMessage(`✓ Dataset combinado listo para análisis: ${combinedDf.length} filas, ${combinedDf._columns ? combinedDf._columns.length : 0} columnas`, "success");

                // Generar el informe
                const reportResults = this.generateReport(combinedDf, this.uploadedFilenames);

                return reportResults;
            }

            saveMergedFiles(df) {
                if (!df || df.length === 0) {
                    this.addConsoleMessage("No hay datos para guardar.", "warning");
                    return;
                }

                // Crear nombre base
                let baseName = "fusionado";
                if (this.uploadedFilenames.length > 0) {
                    const names = this.uploadedFilenames.slice(0, 2)
                        .map(f => f.replace(/\.[^/.]+$/, ""));
                    baseName = names.join('_y_');
                    if (this.uploadedFilesInfo.length > 2) {
                        baseName += `_y_${this.uploadedFilesInfo.length - 2}_mas`;
                    }
                }

                // Guardar como CSV
                const csvFilename = `datos_fusionados_${baseName}.csv`;
                this.mergedFilenameCSV = csvFilename;
                this.addConsoleMessage(`✓ Archivo fusionado preparado como CSV: ${csvFilename}`, "success");

                // Guardar como Excel
                const excelFilename = `datos_fusionados_${baseName}.xlsx`;
                this.mergedFilenameExcel = excelFilename;
                this.addConsoleMessage(`✓ Archivo fusionado preparado como Excel: ${excelFilename}`, "success");

                return {
                    csvFilename,
                    excelFilename,
                    csvData: this.convertToCSV(df),
                    excelData: df
                };
            }

            convertToCSV(df) {
                const headers = df._columns || (df.length > 0 ? Object.keys(df[0]) : []);
                const rows = df.map(row => 
                    headers.map(header => {
                        const cell = row[header];
                        if (cell === null || cell === undefined) return '';
                        if (typeof cell === 'string' && (cell.includes(',') || cell.includes('"'))) {
                            return `"${cell.replace(/"/g, '""')}"`;
                        }
                        return String(cell);
                    }).join(',')
                );
                
                return [headers.join(','), ...rows].join('\n');
            }

            getStats() {
                const totalRows = this.tempDataframes.reduce((sum, df) => sum + df.length, 0);
                const totalColumns = this.tempDataframes[0] ? (this.tempDataframes[0]._columns || []).length : 0;
                
                return {
                    files: this.tempDataframes.length,
                    rows: totalRows,
                    columns: totalColumns
                };
            }
        }

        // Inicialización de la aplicación
        document.addEventListener('DOMContentLoaded', function() {
            // Crear instancia del analizador
            const analyzer = new DataQualityAnalyzer();
            
            // Referencias a elementos DOM
            const fileUpload = document.getElementById('file-upload');
            const selectedFiles = document.getElementById('selected-files');
            const analyzeBtn = document.getElementById('analyze-btn');
            const summaryBtn = document.getElementById('summary-btn');
            const clearBtn = document.getElementById('clear-btn');
            const clearConsoleBtn = document.getElementById('clear-console');
            const consoleOutput = document.getElementById('console-output');
            const summaryModal = document.getElementById('summary-modal');
            const closeModal = document.querySelector('.close-modal');
            const summaryContent = document.getElementById('summary-content');
            const loadingOverlay = document.getElementById('loading-overlay');
            const downloadSection = document.getElementById('download-section');
            
            // Elementos de estadísticas
            const fileCount = document.getElementById('file-count');
            const recordCount = document.getElementById('record-count');
            const columnCount = document.getElementById('column-count');
            
            // Tab system
            const tabBtns = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            
            // Initialize app
            initApp();
            
            function initApp() {
                // Mostrar mensaje de bienvenida en consola
                addConsoleMessage('Bienvenido al Analizador de Calidad de Datos. Sube tus archivos para comenzar.', 'info');
                
                // Actualizar estadísticas iniciales
                updateStats();
                
                // Configurar event listeners
                setupEventListeners();
            }
            
            function setupEventListeners() {
                // File upload
                fileUpload.addEventListener('change', handleFileUpload);
                
                // Botones principales
                analyzeBtn.addEventListener('click', handleAnalyze);
                summaryBtn.addEventListener('click', handleSummary);
                clearBtn.addEventListener('click', handleClear);
                clearConsoleBtn.addEventListener('click', handleClearConsole);
                
                // Modal
                closeModal.addEventListener('click', () => {
                    summaryModal.style.display = 'none';
                });
                
                window.addEventListener('click', (e) => {
                    if (e.target === summaryModal) {
                        summaryModal.style.display = 'none';
                    }
                });
                
                // Tab system
                tabBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tabId = btn.getAttribute('data-tab');
                        switchTab(tabId);
                    });
                });
                
                // Botones de descarga
                document.querySelectorAll('.btn-download').forEach(btn => {
                    btn.addEventListener('click', handleDownload);
                });
            }
            
            async function handleFileUpload(e) {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                
                showLoading(true);
                
                selectedFiles.textContent = `${files.length} archivo(s) seleccionado(s): ${files.map(f => f.name).join(', ')}`;
                
                for (const file of files) {
                    const reader = new FileReader();
                    
                    await new Promise((resolve) => {
                        reader.onload = async function(event) {
                            const content = event.target.result;
                            const result = await analyzer.addFileToAnalysis(content, file.name);
                            
                            // Mostrar mensaje en consola
                            const consoleMsg = analyzer.addConsoleMessage(result.message, 
                                result.success ? 'success' : 'warning');
                            addConsoleMessage(consoleMsg.message, consoleMsg.type);
                            
                            // Actualizar estadísticas
                            updateStats();
                            
                            resolve();
                        };
                        
                        if (file.name.toLowerCase().endsWith('.csv')) {
                            reader.readAsText(file);
                        } else {
                            reader.readAsArrayBuffer(file);
                        }
                    });
                }
                
                showLoading(false);
                fileUpload.value = '';
            }
            
            function handleAnalyze() {
                if (analyzer.tempDataframes.length === 0) {
                    addConsoleMessage('No hay archivos cargados para analizar. Por favor, cargue al menos un archivo.', 'warning');
                    return;
                }
                
                showLoading(true);
                
                // Procesar datos combinados
                const results = analyzer.processCombinedData();
                
                if (results) {
                    // Mostrar resultados en las pestañas
                    displayResults(results);
                    
                    // Generar archivos para descarga
                    const filesData = analyzer.saveMergedFiles(analyzer.combinedData);
                    
                    // Preparar datos para descarga
                    prepareDownloads(filesData, results);
                    
                    // Mostrar sección de descargas
                    downloadSection.style.display = 'block';
                    
                    // Mostrar mensaje final
                    addConsoleMessage('✓ Análisis completado exitosamente. Revise los resultados y descargue los archivos.', 'success');
                }
                
                showLoading(false);
            }
            
            function handleSummary() {
                const summary = analyzer.getUploadSummary();
                summaryContent.textContent = summary;
                summaryModal.style.display = 'block';
            }
            
            function handleClear() {
                analyzer.clearUploadedFiles();
                selectedFiles.textContent = 'No hay archivos seleccionados';
                updateStats();
                
                // Limpiar resultados
                clearResults();
                
                // Ocultar sección de descargas
                downloadSection.style.display = 'none';
                
                addConsoleMessage('✓ Todos los archivos han sido eliminados de la lista de carga.', 'info');
            }
            
            function handleClearConsole() {
                analyzer.consoleMessages = [];
                consoleOutput.innerHTML = `
                    <div class="welcome-message">
                        <i class="fas fa-robot"></i>
                        <p>Bienvenido al Analizador de Calidad de Datos. Sube tus archivos para comenzar.</p>
                    </div>
                `;
            }
            
            function handleDownload(e) {
                const type = e.target.getAttribute('data-type') || 
                            e.target.closest('.btn-download').getAttribute('data-type');
                
                switch(type) {
                    case 'csv':
                        downloadCSV();
                        break;
                    case 'excel':
                        downloadExcel();
                        break;
                    case 'report':
                        downloadReport();
                        break;
                }
            }
            
            function downloadCSV() {
                if (!analyzer.combinedData) return;
                
                const csvData = analyzer.convertToCSV(analyzer.combinedData);
                const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                link.href = url;
                link.download = analyzer.mergedFilenameCSV;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                addConsoleMessage(`✓ Archivo CSV descargado: ${analyzer.mergedFilenameCSV}`, 'success');
            }
            
            function downloadExcel() {
                if (!analyzer.combinedData) return;
                
                try {
                    // Crear hoja de cálculo
                    const ws = XLSX.utils.json_to_sheet(analyzer.combinedData);
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, "Datos");
                    
                    // Generar archivo
                    XLSX.writeFile(wb, analyzer.mergedFilenameExcel);
                    
                    addConsoleMessage(`✓ Archivo Excel descargado: ${analyzer.mergedFilenameExcel}`, 'success');
                } catch (error) {
                    addConsoleMessage(`❌ Error al generar archivo Excel: ${error.message}`, 'error');
                }
            }
            
            function downloadReport() {
                if (!analyzer.reportText) return;
                
                const blob = new Blob([analyzer.reportText], { type: 'text/plain;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                link.href = url;
                link.download = analyzer.reportFilename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                addConsoleMessage(`✓ Informe descargado: ${analyzer.reportFilename}`, 'success');
            }
            
            function displayResults(results) {
                // Mostrar datos faltantes
                if (results.missingData) {
                    displayTable('missing', results.missingData);
                    document.getElementById('missing-data').style.display = 'none';
                } else {
                    document.getElementById('missing-data').style.display = 'block';
                }
                
                // Mostrar duplicados
                if (results.duplicatesData) {
                    displayTable('duplicates', results.duplicatesData);
                    document.getElementById('duplicates-data').style.display = 'none';
                } else {
                    document.getElementById('duplicates-data').style.display = 'block';
                }
                
                // Mostrar inconsistencias
                if (results.inconsistenciesData) {
                    displayTable('inconsistencies', results.inconsistenciesData);
                    document.getElementById('inconsistencies-data').style.display = 'none';
                } else {
                    document.getElementById('inconsistencies-data').style.display = 'block';
                }
                
                // Mostrar tipos mezclados
                if (results.mixedTypeData) {
                    displayTable('mixed', results.mixedTypeData);
                    document.getElementById('mixed-data').style.display = 'none';
                } else {
                    document.getElementById('mixed-data').style.display = 'block';
                }
                
                // Mostrar valores atípicos
                if (results.outliersData) {
                    displayTable('outliers', results.outliersData);
                    document.getElementById('outliers-data').style.display = 'none';
                } else {
                    document.getElementById('outliers-data').style.display = 'block';
                }
            }
            
            function displayTable(type, data) {
                const containerId = `${type}-table`;
                const container = document.getElementById(containerId);
                
                if (!container) return;
                
                // Crear tabla
                const table = document.createElement('table');
                table.className = 'data-table';
                
                // Crear encabezados
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                Object.keys(data[0]).forEach(key => {
                    const th = document.createElement('th');
                    th.textContent = key;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Crear cuerpo de la tabla
                const tbody = document.createElement('tbody');
                
                data.forEach(row => {
                    const tr = document.createElement('tr');
                    
                    Object.values(row).forEach(value => {
                        const td = document.createElement('td');
                        td.textContent = value !== null && value !== undefined ? String(value) : '';
                        tr.appendChild(td);
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                
                // Limpiar contenedor y agregar tabla
                container.innerHTML = '';
                container.appendChild(table);
            }
            
            function clearResults() {
                // Limpiar todas las tablas
                ['missing', 'duplicates', 'inconsistencies', 'mixed', 'outliers'].forEach(type => {
                    const container = document.getElementById(`${type}-table`);
                    const noData = document.getElementById(`${type}-data`);
                    
                    if (container) container.innerHTML = '';
                    if (noData) noData.style.display = 'block';
                });
            }
            
            function prepareDownloads(filesData, reportResults) {
                // Actualizar nombres de archivos en la UI
                const csvDownload = document.querySelector('#csv-download h3');
                const excelDownload = document.querySelector('#excel-download h3');
                const reportDownload = document.querySelector('#report-download h3');
                
                if (csvDownload) csvDownload.textContent = `Archivo Fusionado (CSV) - ${analyzer.mergedFilenameCSV}`;
                if (excelDownload) excelDownload.textContent = `Archivo Fusionado (Excel) - ${analyzer.mergedFilenameExcel}`;
                if (reportDownload) reportDownload.textContent = `Informe de Análisis - ${analyzer.reportFilename}`;
            }
            
            function addConsoleMessage(message, type) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `console-message message-${type}`;
                
                const timestamp = new Date().toLocaleTimeString();
                const icon = getMessageIcon(type);
                
                messageDiv.innerHTML = `
                    <span class="timestamp">[${timestamp}]</span>
                    <span class="message-icon">${icon}</span>
                    <span class="message-text">${message}</span>
                `;
                
                // Remover mensaje de bienvenida si existe
                const welcomeMsg = consoleOutput.querySelector('.welcome-message');
                if (welcomeMsg) {
                    welcomeMsg.remove();
                }
                
                consoleOutput.appendChild(messageDiv);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
            
            function getMessageIcon(type) {
                const icons = {
                    success: '✓',
                    warning: '⚠️',
                    error: '❌',
                    info: 'ℹ️'
                };
                return icons[type] || 'ℹ️';
            }
            
            function updateStats() {
                const stats = analyzer.getStats();
                if (fileCount) fileCount.textContent = stats.files;
                if (recordCount) recordCount.textContent = stats.rows;
                if (columnCount) columnCount.textContent = stats.columns;
            }
            
            function switchTab(tabId) {
                // Remover clase active de todas las pestañas
                tabBtns.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                
                // Agregar clase active a la pestaña seleccionada
                const activeBtn = document.querySelector(`[data-tab="${tabId}"]`);
                const activeContent = document.getElementById(`${tabId}-tab`);
                
                if (activeBtn) activeBtn.classList.add('active');
                if (activeContent) activeContent.classList.add('active');
            }
            
            function showLoading(show) {
                if (loadingOverlay) {
                    loadingOverlay.style.display = show ? 'flex' : 'none';
                }
            }
        });
    </script>
</body>
</html>
